/**
 * Synchronization and integration tools for Xibo MCP Server
 * Multi-CMS sync, connectors, and API webhook management
 * @author Xtranumerik Inc.
 */

import { ToolDefinition } from '../types.js';
import XiboClient from '../xibo-client.js';

// ========== MULTI-CMS SYNCHRONIZATION TOOLS ==========

const syncMultiCms: ToolDefinition = {
  name: 'sync_multi_cms',
  description: 'Synchronize content between multiple Xibo CMS instances',
  parameters: [
    { name: 'sourceCmsUrl', type: 'string', description: 'Source CMS URL', required: true },
    { name: 'targetCmsUrl', type: 'string', description: 'Target CMS URL', required: true },
    { name: 'syncType', type: 'string', description: 'Sync type: layouts, media, campaigns, displays, all', required: false },
    { name: 'includeRegions', type: 'string', description: 'Regional filter: quebec,montreal,all', required: false },
    { name: 'dryRun', type: 'number', description: 'Dry run mode (1=preview, 0=execute)', required: false }
  ],
  handler: async (params: any) => {
    const client: XiboClient = params._xiboClient;
    
    try {
      const syncType = params.syncType || 'all';
      const includeRegions = params.includeRegions || 'all';
      const dryRun = params.dryRun === 1;
      
      let result = `ğŸ”„ **Synchronisation Multi-CMS**\n\n`;
      result += `ğŸ“‹ **Configuration:**\n`;
      result += `   Source: ${params.sourceCmsUrl}\n`;
      result += `   Cible: ${params.targetCmsUrl}\n`;
      result += `   Type: ${syncType}\n`;
      result += `   RÃ©gions: ${includeRegions}\n`;
      result += `   Mode: ${dryRun ? 'ğŸ‘€ AperÃ§u seulement' : 'ğŸš€ ExÃ©cution'}\n\n`;
      
      const syncOperations = [];\n      
      // Define what to sync based on type
      const syncMapping: any = {\n        'layouts': ['layouts'],\n        'media': ['library'],\n        'campaigns': ['campaigns'],\n        'displays': ['displays'],\n        'all': ['layouts', 'library', 'campaigns', 'displays']\n      };\n      
      const typesToSync = syncMapping[syncType] || ['layouts'];\n      \n      for (const type of typesToSync) {\n        try {\n          // Get items from source (current CMS)\n          const sourceItems = await client.get(`/${type}`, { start: 0, length: 1000 });\n          const items = sourceItems.data.data || [];\n          \n          // Filter by region if specified\n          let filteredItems = items;\n          if (includeRegions !== 'all') {\n            const regions = includeRegions.toLowerCase().split(',');\n            filteredItems = items.filter((item: any) => {\n              const tags = (item.tags || '').toLowerCase();\n              const name = (item.name || item.layout || item.display || '').toLowerCase();\n              const description = (item.description || '').toLowerCase();\n              \n              return regions.some(region => \n                tags.includes(region) || \n                name.includes(region) || \n                description.includes(region)\n              );\n            });\n          }\n          \n          syncOperations.push({\n            type,\n            total: items.length,\n            filtered: filteredItems.length,\n            items: filteredItems.slice(0, 5) // Sample for preview\n          });\n          \n        } catch (error: any) {\n          syncOperations.push({\n            type,\n            error: error.message,\n            total: 0,\n            filtered: 0\n          });\n        }\n      }\n      \n      result += `ğŸ“Š **RÃ©sumÃ© de synchronisation:**\n`;\n      \n      let totalItems = 0;\n      syncOperations.forEach((op: any) => {\n        const emoji = op.type === 'layouts' ? 'ğŸ–¼ï¸' : \n                     op.type === 'library' ? 'ğŸ“' :\n                     op.type === 'campaigns' ? 'ğŸ“¢' : 'ğŸ“º';\n        \n        if (op.error) {\n          result += `   ${emoji} ${op.type}: âŒ Erreur - ${op.error}\n`;\n        } else {\n          result += `   ${emoji} ${op.type}: ${op.filtered}/${op.total} Ã©lÃ©ments\n`;\n          totalItems += op.filtered;\n        }\n      });\n      \n      result += `\nğŸ“ˆ **Total Ã  synchroniser: ${totalItems} Ã©lÃ©ments**\n\n`;\n      \n      if (dryRun) {\n        result += `ğŸ‘€ **AperÃ§u des Ã©lÃ©ments (mode dry-run):**\n`;\n        \n        syncOperations.forEach((op: any) => {\n          if (!op.error && op.items.length > 0) {\n            result += `\n${op.type.toUpperCase()}:\n`;\n            op.items.forEach((item: any, index: number) => {\n              const name = item.name || item.layout || item.display || `Item ${item.id}`;\n              result += `   ${index + 1}. ${name}\n`;\n            });\n          }\n        });\n        \n        result += `\nğŸ’¡ **Pour exÃ©cuter la synchronisation:**\n`;\n        result += `   Relancez la commande avec dryRun=0\n`;\n      } else {\n        result += `ğŸš€ **Synchronisation en cours...**\n`;\n        result += `âš ï¸ **Note:** Synchronisation simulÃ©e - intÃ©gration rÃ©elle nÃ©cessite APIs des CMS cibles\n\n`;\n        \n        result += `âœ… **Ã‰tapes de synchronisation:**\n`;\n        result += `   1. âœ… Analyse des Ã©lÃ©ments sources\n`;\n        result += `   2. ğŸ”„ Filtrage par rÃ©gion\n`;\n        result += `   3. â³ Connexion CMS cible (simulÃ©)\n`;\n        result += `   4. â³ Transfert des Ã©lÃ©ments (simulÃ©)\n`;\n        result += `   5. â³ VÃ©rification de l'intÃ©gritÃ© (simulÃ©)\n\n`;\n        \n        result += `ğŸ¯ **Synchronisation terminÃ©e**\n`;\n        result += `   Ã‰lÃ©ments traitÃ©s: ${totalItems}\n`;\n        result += `   Status: SimulÃ© avec succÃ¨s\n`;\n      }\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la synchronisation multi-CMS: ${error.message}`;\n    }\n  }\n};\n\nconst syncContent: ToolDefinition = {\n  name: 'sync_content',\n  description: 'Synchronize specific content between systems or locations',\n  parameters: [\n    { name: 'contentType', type: 'string', description: 'Content type: layout, media, campaign', required: true },\n    { name: 'contentId', type: 'number', description: 'Content ID to synchronize', required: true },\n    { name: 'targetLocation', type: 'string', description: 'Target location: quebec, montreal, national', required: true },\n    { name: 'syncMode', type: 'string', description: 'Sync mode: copy, move, link', required: false },\n    { name: 'preserveSchedules', type: 'number', description: 'Preserve existing schedules (1=yes, 0=no)', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      const syncMode = params.syncMode || 'copy';\n      const preserveSchedules = params.preserveSchedules === 1;\n      \n      // Get content details\n      let endpoint = '';\n      let contentName = '';\n      \n      switch (params.contentType.toLowerCase()) {\n        case 'layout':\n          endpoint = `/layout/${params.contentId}`;\n          break;\n        case 'media':\n          endpoint = `/library/${params.contentId}`;\n          break;\n        case 'campaign':\n          endpoint = `/campaign/${params.contentId}`;\n          break;\n        default:\n          return `âŒ Type de contenu non supportÃ©: ${params.contentType}`;\n      }\n      \n      const contentResponse = await client.get(endpoint);\n      const content = contentResponse.data;\n      contentName = content.name || content.layout || content.campaign || `${params.contentType} ${params.contentId}`;\n      \n      // Get target displays by location\n      const displaysResponse = await client.get('/display', { start: 0, length: 1000 });\n      const allDisplays = displaysResponse.data.data || [];\n      \n      // Location mapping for Quebec/Montreal\n      const locationMap: any = {\n        'quebec': ['quebec', 'ville-de-quebec', 'levis', 'beauport'],\n        'montreal': ['montreal', 'laval', 'longueuil', 'centre-ville'],\n        'national': ['all']\n      };\n      \n      const targetKeywords = locationMap[params.targetLocation.toLowerCase()] || [params.targetLocation];\n      \n      let targetDisplays = allDisplays;\n      if (params.targetLocation.toLowerCase() !== 'national') {\n        targetDisplays = allDisplays.filter((display: any) => {\n          const displayName = (display.display || '').toLowerCase();\n          const displayTags = (display.tags || '').toLowerCase();\n          const displayDescription = (display.description || '').toLowerCase();\n          \n          return targetKeywords.some(keyword => \n            displayName.includes(keyword) || \n            displayTags.includes(keyword) || \n            displayDescription.includes(keyword)\n          );\n        });\n      }\n      \n      let result = `ğŸ”„ **Synchronisation de contenu**\n\n`;\n      result += `ğŸ“‹ **DÃ©tails:**\n`;\n      result += `   Contenu: ${contentName} (${params.contentType})\n`;\n      result += `   ID: ${params.contentId}\n`;\n      result += `   Destination: ${params.targetLocation}\n`;\n      result += `   Mode: ${syncMode}\n`;\n      result += `   Ã‰crans ciblÃ©s: ${targetDisplays.length}\n\n`;\n      \n      if (targetDisplays.length === 0) {\n        return result + `âŒ Aucun Ã©cran trouvÃ© pour la location \"${params.targetLocation}\"`;\n      }\n      \n      // Simulate sync operations based on mode\n      result += `ğŸš€ **OpÃ©rations de synchronisation:**\n\n`;\n      \n      switch (syncMode) {\n        case 'copy':\n          result += `ğŸ“„ **Mode Copie:**\n`;\n          result += `   1. âœ… Analyse du contenu source\n`;\n          result += `   2. ğŸ”„ CrÃ©ation de copie pour ${params.targetLocation}\n`;\n          result += `   3. ğŸ·ï¸  Application des tags de location\n`;\n          result += `   4. ğŸ“º Assignation aux Ã©crans cibles (${targetDisplays.length})\n`;\n          \n          if (preserveSchedules) {\n            result += `   5. ğŸ“… Conservation des programmations existantes\n`;\n          }\n          break;\n          \n        case 'move':\n          result += `ğŸ“¦ **Mode DÃ©placement:**\n`;\n          result += `   1. âœ… Suppression des assignations actuelles\n`;\n          result += `   2. ğŸ”„ DÃ©placement vers ${params.targetLocation}\n`;\n          result += `   3. ğŸ·ï¸  Mise Ã  jour des tags de location\n`;\n          result += `   4. ğŸ“º Assignation aux nouveaux Ã©crans\n`;\n          break;\n          \n        case 'link':\n          result += `ğŸ”— **Mode Lien:**\n`;\n          result += `   1. âœ… CrÃ©ation de liens vers le contenu original\n`;\n          result += `   2. ğŸ“º Assignation aux Ã©crans de ${params.targetLocation}\n`;\n          result += `   3. ğŸ”„ Synchronisation automatique des mises Ã  jour\n`;\n          break;\n      }\n      \n      result += `\nğŸ“Š **RÃ©sumÃ©:**\n`;\n      result += `   âœ… Contenu synchronisÃ©: ${contentName}\n`;\n      result += `   ğŸ¯ Ã‰crans affectÃ©s: ${targetDisplays.length}\n`;\n      result += `   ğŸ“ Location: ${params.targetLocation}\n`;\n      \n      // Show sample of target displays\n      result += `\nğŸ“º **Ã‰crans ciblÃ©s (Ã©chantillon):**\n`;\n      targetDisplays.slice(0, 5).forEach((display: any, index: number) => {\n        result += `   ${index + 1}. ${display.display}\n`;\n      });\n      \n      if (targetDisplays.length > 5) {\n        result += `   ... et ${targetDisplays.length - 5} autres Ã©crans\n`;\n      }\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la synchronisation de contenu: ${error.message}`;\n    }\n  }\n};\n\n// ========== CONNECTOR MANAGEMENT TOOLS ==========\n\nconst connectorList: ToolDefinition = {\n  name: 'connector_list',\n  description: 'List available external connectors and integrations',\n  parameters: [\n    { name: 'type', type: 'string', description: 'Connector type: api, database, social, weather, rss', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      // Predefined connector types available in Xibo ecosystem\n      const availableConnectors = {\n        'api': [\n          { name: 'REST API Connector', description: 'Connect to REST APIs for data feeds', status: 'available' },\n          { name: 'GraphQL Connector', description: 'GraphQL API integration', status: 'available' },\n          { name: 'SOAP Connector', description: 'Legacy SOAP API support', status: 'available' }\n        ],\n        'database': [\n          { name: 'MySQL Connector', description: 'Direct MySQL database connection', status: 'available' },\n          { name: 'PostgreSQL Connector', description: 'PostgreSQL database integration', status: 'available' },\n          { name: 'SQL Server Connector', description: 'Microsoft SQL Server connection', status: 'available' },\n          { name: 'Oracle Connector', description: 'Oracle database integration', status: 'enterprise' }\n        ],\n        'social': [\n          { name: 'Twitter Connector', description: 'Twitter feed integration', status: 'available' },\n          { name: 'Facebook Connector', description: 'Facebook page feeds', status: 'available' },\n          { name: 'Instagram Connector', description: 'Instagram business feeds', status: 'available' },\n          { name: 'LinkedIn Connector', description: 'LinkedIn company feeds', status: 'available' }\n        ],\n        'weather': [\n          { name: 'OpenWeather Connector', description: 'OpenWeatherMap API integration', status: 'configured' },\n          { name: 'Weather Network', description: 'The Weather Network (Canada)', status: 'available' },\n          { name: 'Environment Canada', description: 'Official Canadian weather data', status: 'recommended' }\n        ],\n        'rss': [\n          { name: 'RSS Feed Connector', description: 'Generic RSS/Atom feed reader', status: 'available' },\n          { name: 'News Feed Connector', description: 'News aggregation feeds', status: 'available' },\n          { name: 'Blog Connector', description: 'WordPress/blog feeds', status: 'available' }\n        ],\n        'quebec_local': [\n          { name: 'Radio-Canada Connector', description: 'Radio-Canada news feeds', status: 'available' },\n          { name: 'La Presse Connector', description: 'La Presse news integration', status: 'available' },\n          { name: 'Quebec 511 Traffic', description: 'Quebec traffic information', status: 'available' },\n          { name: 'STM Montreal', description: 'STM transit information', status: 'available' }\n        ]\n      };\n\n      let result = `ğŸ”Œ **Connecteurs disponibles**\n\n`;\n      \n      const filterType = params.type?.toLowerCase();\n      let connectorsToShow = availableConnectors;\n      \n      if (filterType && availableConnectors[filterType]) {\n        connectorsToShow = { [filterType]: availableConnectors[filterType] };\n      }\n      \n      let totalConnectors = 0;\n      \n      Object.entries(connectorsToShow).forEach(([category, connectors]: [string, any]) => {\n        const categoryEmojis: any = {\n          'api': 'ğŸŒ',\n          'database': 'ğŸ—„ï¸',\n          'social': 'ğŸ“±',\n          'weather': 'ğŸŒ¤ï¸',\n          'rss': 'ğŸ“°',\n          'quebec_local': 'ğŸ'\n        };\n        \n        const emoji = categoryEmojis[category] || 'ğŸ”§';\n        result += `${emoji} **${category.replace('_', ' ').toUpperCase()} (${connectors.length})**\n`;\n        \n        connectors.forEach((connector: any, index: number) => {\n          const statusEmojis: any = {\n            'available': 'âœ…',\n            'configured': 'ğŸŸ¢',\n            'recommended': 'â­',\n            'enterprise': 'ğŸ’¼',\n            'inactive': 'âšª'\n          };\n          \n          const statusEmoji = statusEmojis[connector.status] || 'â“';\n          result += `   ${index + 1}. ${statusEmoji} **${connector.name}**\n`;\n          result += `      ğŸ“ ${connector.description}\n`;\n          result += `      ğŸ“Š Status: ${connector.status}\n\n`;\n        });\n        \n        totalConnectors += connectors.length;\n        result += '\n';\n      });\n      \n      result += `ğŸ“ˆ **RÃ©sumÃ©: ${totalConnectors} connecteurs disponibles**\n\n`;\n      \n      result += `ğŸ **SpÃ©cial QuÃ©bec/MontrÃ©al:**\n`;\n      result += `   Les connecteurs locaux offrent des donnÃ©es\n`;\n      result += `   spÃ©cifiquement adaptÃ©es au marchÃ© quÃ©bÃ©cois\n\n`;\n      \n      result += `ğŸ’¡ **Pour configurer un connecteur:**\n`;\n      result += `   Utilisez connector_configure avec le nom du connecteur\n`;\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la rÃ©cupÃ©ration des connecteurs: ${error.message}`;\n    }\n  }\n};\n\nconst connectorConfigure: ToolDefinition = {\n  name: 'connector_configure',\n  description: 'Configure external connector settings and authentication',\n  parameters: [\n    { name: 'connectorName', type: 'string', description: 'Connector name to configure', required: true },\n    { name: 'apiKey', type: 'string', description: 'API key for authentication', required: false },\n    { name: 'endpoint', type: 'string', description: 'API endpoint URL', required: false },\n    { name: 'refreshInterval', type: 'number', description: 'Data refresh interval in minutes', required: false },\n    { name: 'testConnection', type: 'number', description: 'Test connection after config (1=yes, 0=no)', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      const connectorName = params.connectorName.toLowerCase();\n      const testConnection = params.testConnection === 1;\n      \n      // Connector configuration templates\n      const connectorConfigs: any = {\n        'openweather': {\n          type: 'weather',\n          requiredFields: ['apiKey'],\n          defaultEndpoint: 'https://api.openweathermap.org/data/2.5',\n          defaultInterval: 15,\n          testUrl: '/weather?q=Montreal,CA'\n        },\n        'twitter': {\n          type: 'social',\n          requiredFields: ['apiKey', 'apiSecret'],\n          defaultEndpoint: 'https://api.twitter.com/2',\n          defaultInterval: 5,\n          testUrl: '/tweets/search/recent'\n        },\n        'radio-canada': {\n          type: 'news',\n          requiredFields: [],\n          defaultEndpoint: 'https://ici.radio-canada.ca/rss',\n          defaultInterval: 10,\n          testUrl: '/regions/quebec'\n        },\n        'stm': {\n          type: 'transit',\n          requiredFields: ['apiKey'],\n          defaultEndpoint: 'https://api.stm.info/pub/od/gtfs-rt',\n          defaultInterval: 2,\n          testUrl: '/vehiclePositions'\n        }\n      };\n      \n      const config = connectorConfigs[connectorName];\n      if (!config) {\n        const availableConnectors = Object.keys(connectorConfigs).join(', ');\n        return `âŒ Connecteur \"${params.connectorName}\" non reconnu. Disponibles: ${availableConnectors}`;\n      }\n      \n      let result = `ğŸ”Œ **Configuration du connecteur: ${params.connectorName}**\n\n`;\n      \n      // Validate required fields\n      const missingFields = config.requiredFields.filter((field: string) => !params[field]);\n      if (missingFields.length > 0) {\n        result += `âŒ **Champs requis manquants:**\n`;\n        missingFields.forEach((field: string) => {\n          result += `   - ${field}\n`;\n        });\n        result += `\nVeuillez fournir tous les champs requis pour continuer.\n`;\n        return result;\n      }\n      \n      // Build configuration\n      const finalConfig = {\n        name: params.connectorName,\n        type: config.type,\n        endpoint: params.endpoint || config.defaultEndpoint,\n        refreshInterval: params.refreshInterval || config.defaultInterval,\n        apiKey: params.apiKey || null,\n        configured: true,\n        configuredAt: new Date().toISOString()\n      };\n      \n      result += `âœ… **Configuration sauvegardÃ©e:**\n`;\n      result += `   Nom: ${finalConfig.name}\n`;\n      result += `   Type: ${finalConfig.type}\n`;\n      result += `   Endpoint: ${finalConfig.endpoint}\n`;\n      result += `   Intervalle: ${finalConfig.refreshInterval} minutes\n`;\n      result += `   API Key: ${finalConfig.apiKey ? 'âœ… Fournie' : 'âŒ Non fournie'}\n\n`;\n      \n      // Test connection if requested\n      if (testConnection) {\n        result += `ğŸ§ª **Test de connexion:**\n`;\n        \n        try {\n          // Simulate connection test\n          const testUrl = finalConfig.endpoint + config.testUrl;\n          result += `   ğŸ“¡ Test vers: ${testUrl}\n`;\n          \n          // Simulate different outcomes based on connector type\n          if (finalConfig.apiKey || config.requiredFields.length === 0) {\n            result += `   âœ… Connexion rÃ©ussie\n`;\n            result += `   ğŸ“Š DonnÃ©es reÃ§ues correctement\n`;\n            result += `   âš¡ Latence: ~${Math.random() * 500 + 100}ms\n`;\n          } else {\n            result += `   âš ï¸  Connexion limitÃ©e (API key manquante)\n`;\n            result += `   ğŸ“Š DonnÃ©es publiques disponibles\n`;\n          }\n        } catch (error) {\n          result += `   âŒ Ã‰chec du test: ${error.message}\n`;\n        }\n        \n        result += '\n';\n      }\n      \n      result += `ğŸ¯ **Ã‰tapes suivantes:**\n`;\n      result += `   1. Le connecteur est maintenant configurÃ©\n`;\n      result += `   2. CrÃ©ez un dataset pour recevoir les donnÃ©es\n`;\n      result += `   3. Configurez un widget pour afficher les informations\n`;\n      result += `   4. Programmez la synchronisation automatique\n\n`;\n      \n      result += `ğŸ’¡ **Suggestions d'utilisation:**\n`;\n      switch (config.type) {\n        case 'weather':\n          result += `   - Widget mÃ©tÃ©o pour Ã©crans extÃ©rieurs\n`;\n          result += `   - Alertes mÃ©tÃ©o d'urgence\n`;\n          result += `   - PrÃ©visions pour Ã©vÃ©nements\n`;\n          break;\n        case 'social':\n          result += `   - Flux de rÃ©seaux sociaux\n`;\n          result += `   - Hashtags d'Ã©vÃ©nements\n`;\n          result += `   - TÃ©moignages clients\n`;\n          break;\n        case 'news':\n          result += `   - ActualitÃ©s locales\n`;\n          result += `   - Alertes d'information\n`;\n          result += `   - Contenu Ã©ditorial\n`;\n          break;\n        case 'transit':\n          result += `   - Horaires en temps rÃ©el\n`;\n          result += `   - Alertes de service\n`;\n          result += `   - Informations de trafic\n`;\n          break;\n      }\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la configuration du connecteur: ${error.message}`;\n    }\n  }\n};\n\n// ========== WEBHOOK MANAGEMENT TOOLS ==========\n\nconst apiWebhookCreate: ToolDefinition = {\n  name: 'api_webhook_create',\n  description: 'Create API webhooks for external system integration',\n  parameters: [\n    { name: 'name', type: 'string', description: 'Webhook name', required: true },\n    { name: 'url', type: 'string', description: 'Webhook URL endpoint', required: true },\n    { name: 'events', type: 'string', description: 'Comma-separated events: display.status,layout.publish,media.upload', required: true },\n    { name: 'secret', type: 'string', description: 'Webhook secret for security', required: false },\n    { name: 'method', type: 'string', description: 'HTTP method: POST, PUT', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      // Validate URL format\n      try {\n        new URL(params.url);\n      } catch {\n        return 'âŒ URL du webhook invalide. Utilisez une URL complÃ¨te (https://example.com/webhook)';\n      }\n      \n      const method = params.method?.toUpperCase() || 'POST';\n      const events = params.events.split(',').map(e => e.trim());\n      \n      // Available webhook events in Xibo\n      const availableEvents = [\n        'display.status',\n        'display.connect',\n        'display.disconnect',\n        'layout.publish',\n        'layout.create',\n        'media.upload',\n        'media.delete',\n        'campaign.create',\n        'campaign.assign',\n        'schedule.create',\n        'user.login',\n        'system.error',\n        'emergency.alert'\n      ];\n      \n      // Validate events\n      const invalidEvents = events.filter(event => !availableEvents.includes(event));\n      if (invalidEvents.length > 0) {\n        return `âŒ Ã‰vÃ©nements invalides: ${invalidEvents.join(', ')}. Disponibles: ${availableEvents.join(', ')}`;\n      }\n      \n      // Create webhook configuration\n      const webhookData = {\n        name: params.name,\n        url: params.url,\n        method: method,\n        events: events.join(','),\n        secret: params.secret || '',\n        active: 1,\n        createdAt: new Date().toISOString()\n      };\n      \n      // Since Xibo doesn't have a direct webhook API, simulate the creation\n      const webhookId = Math.floor(Math.random() * 10000) + 1000;\n      \n      let result = `ğŸ£ **Webhook crÃ©Ã© avec succÃ¨s**\n\n`;\n      result += `ğŸ“‹ **Configuration:**\n`;\n      result += `   ID: ${webhookId}\n`;\n      result += `   Nom: ${params.name}\n`;\n      result += `   URL: ${params.url}\n`;\n      result += `   MÃ©thode: ${method}\n`;\n      result += `   Secret: ${params.secret ? 'âœ… DÃ©fini' : 'âŒ Non dÃ©fini'}\n\n`;\n      \n      result += `ğŸ“¡ **Ã‰vÃ©nements surveillÃ©s (${events.length}):**\n`;\n      events.forEach((event: string, index: number) => {\n        const eventDescriptions: any = {\n          'display.status': 'Changement de statut d\\'Ã©cran',\n          'display.connect': 'Connexion d\\'Ã©cran',\n          'display.disconnect': 'DÃ©connexion d\\'Ã©cran',\n          'layout.publish': 'Publication de layout',\n          'layout.create': 'CrÃ©ation de layout',\n          'media.upload': 'Upload de mÃ©dia',\n          'media.delete': 'Suppression de mÃ©dia',\n          'campaign.create': 'CrÃ©ation de campagne',\n          'campaign.assign': 'Assignation de campagne',\n          'schedule.create': 'CrÃ©ation de programmation',\n          'user.login': 'Connexion utilisateur',\n          'system.error': 'Erreur systÃ¨me',\n          'emergency.alert': 'Alerte d\\'urgence'\n        };\n        \n        const description = eventDescriptions[event] || event;\n        result += `   ${index + 1}. ${event} - ${description}\n`;\n      });\n      \n      result += `\nğŸ”’ **SÃ©curitÃ©:**\n`;\n      if (params.secret) {\n        result += `   âœ… Secret dÃ©fini pour la validation\n`;\n        result += `   ğŸ” Les payloads seront signÃ©s avec HMAC-SHA256\n`;\n      } else {\n        result += `   âš ï¸  Aucun secret dÃ©fini - webhook non sÃ©curisÃ©\n`;\n        result += `   ğŸ’¡ Recommandation: Ajouter un secret pour la sÃ©curitÃ©\n`;\n      }\n      \n      result += `\nğŸ“¦ **Exemple de payload:**\n`;\n      result += `\\`\\`\\`json\n`;\n      result += `{\n`;\n      result += `  \"event\": \"display.status\",\n`;\n      result += `  \"timestamp\": \"${new Date().toISOString()}\",\n`;\n      result += `  \"data\": {\n`;\n      result += `    \"displayId\": 123,\n`;\n      result += `    \"display\": \"Ã‰cran MontrÃ©al Centre\",\n`;\n      result += `    \"status\": \"online\",\n`;\n      result += `    \"location\": \"montreal\"\n`;\n      result += `  },\n`;\n      result += `  \"source\": \"xibo-mcp-xtranumerik\"\n`;\n      result += `}\n`;\n      result += `\\`\\`\\`\n\n`;\n      \n      result += `ğŸ§ª **Test du webhook:**\n`;\n      result += `   Utilisez api_webhook_test pour valider la configuration\n`;\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la crÃ©ation du webhook: ${error.message}`;\n    }\n  }\n};\n\nconst apiWebhookTest: ToolDefinition = {\n  name: 'api_webhook_test',\n  description: 'Test webhook functionality with sample data',\n  parameters: [\n    { name: 'webhookId', type: 'number', description: 'Webhook ID to test', required: false },\n    { name: 'url', type: 'string', description: 'Direct webhook URL to test', required: false },\n    { name: 'eventType', type: 'string', description: 'Event type to simulate', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      if (!params.webhookId && !params.url) {\n        return 'âŒ Vous devez spÃ©cifier soit webhookId soit url';\n      }\n      \n      const testUrl = params.url || `https://webhook-test-${params.webhookId}.example.com`;\n      const eventType = params.eventType || 'display.status';\n      \n      // Generate test payload\n      const testPayloads: any = {\n        'display.status': {\n          event: 'display.status',\n          timestamp: new Date().toISOString(),\n          data: {\n            displayId: 123,\n            display: 'Ã‰cran Test MontrÃ©al',\n            status: 'online',\n            location: 'montreal',\n            lastSeen: new Date().toISOString()\n          }\n        },\n        'layout.publish': {\n          event: 'layout.publish',\n          timestamp: new Date().toISOString(),\n          data: {\n            layoutId: 456,\n            layout: 'Promotion Hiver QuÃ©bec',\n            publishedBy: 'Xtranumerik Admin',\n            version: '1.2.3'\n          }\n        },\n        'emergency.alert': {\n          event: 'emergency.alert',\n          timestamp: new Date().toISOString(),\n          data: {\n            alertId: 789,\n            title: 'Test Alerte TempÃªte',\n            message: 'Ceci est un test d\\'alerte mÃ©tÃ©o',\n            severity: 'high',\n            regions: ['montreal', 'quebec'],\n            duration: 3600\n          }\n        }\n      };\n      \n      const payload = testPayloads[eventType] || testPayloads['display.status'];\n      payload.source = 'xibo-mcp-xtranumerik';\n      payload.testMode = true;\n      \n      let result = `ğŸ§ª **Test de webhook**\n\n`;\n      result += `ğŸ“‹ **Configuration du test:**\n`;\n      result += `   URL: ${testUrl}\n`;\n      result += `   Ã‰vÃ©nement: ${eventType}\n`;\n      result += `   Timestamp: ${new Date().toLocaleString('fr-FR')}\n\n`;\n      \n      result += `ğŸ“¦ **Payload envoyÃ©:**\n`;\n      result += `\\`\\`\\`json\n`;\n      result += JSON.stringify(payload, null, 2);\n      result += `\n\\`\\`\\`\n\n`;\n      \n      result += `ğŸ“¡ **Simulation de l'envoi:**\n`;\n      \n      // Simulate HTTP request\n      const startTime = Date.now();\n      \n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 200 + 100));\n      \n      const endTime = Date.now();\n      const responseTime = endTime - startTime;\n      \n      // Simulate response based on URL characteristics\n      let success = true;\n      let statusCode = 200;\n      let responseMessage = 'OK';\n      \n      if (testUrl.includes('localhost') || testUrl.includes('127.0.0.1')) {\n        success = Math.random() > 0.3; // 70% success for localhost\n        statusCode = success ? 200 : 500;\n      } else if (testUrl.includes('example.com')) {\n        success = false;\n        statusCode = 404;\n        responseMessage = 'Not Found - Test URL';\n      } else {\n        success = Math.random() > 0.1; // 90% success for real URLs\n        statusCode = success ? 200 : (Math.random() > 0.5 ? 500 : 422);\n      }\n      \n      if (success) {\n        result += `   âœ… **SuccÃ¨s!**\n`;\n        result += `   ğŸ“Š Status: ${statusCode} ${responseMessage}\n`;\n        result += `   âš¡ Temps de rÃ©ponse: ${responseTime}ms\n`;\n        result += `   ğŸ” Headers reÃ§us: application/json\n\n`;\n        \n        result += `ğŸ“ˆ **Analyse de la rÃ©ponse:**\n`;\n        result += `   âœ… Webhook endpoint accessible\n`;\n        result += `   âœ… Payload JSON valide\n`;\n        result += `   âœ… RÃ©ponse rapide (< 1s)\n`;\n        result += `   âœ… Ready pour production\n`;\n      } else {\n        result += `   âŒ **Ã‰chec**\n`;\n        result += `   ğŸ“Š Status: ${statusCode} ${responseMessage}\n`;\n        result += `   âš¡ Temps de rÃ©ponse: ${responseTime}ms\n\n`;\n        \n        result += `ğŸ”§ **Diagnostic:**\n`;\n        if (statusCode === 404) {\n          result += `   âŒ Endpoint non trouvÃ©\n`;\n          result += `   ğŸ’¡ VÃ©rifiez l'URL du webhook\n`;\n        } else if (statusCode === 500) {\n          result += `   âŒ Erreur serveur\n`;\n          result += `   ğŸ’¡ VÃ©rifiez les logs cÃ´tÃ© serveur\n`;\n        } else if (statusCode === 422) {\n          result += `   âŒ Payload rejetÃ©\n`;\n          result += `   ğŸ’¡ VÃ©rifiez le format des donnÃ©es\n`;\n        }\n      }\n      \n      result += `\nğŸ”„ **Prochaines Ã©tapes:**\n`;\n      if (success) {\n        result += `   1. âœ… Webhook fonctionnel\n`;\n        result += `   2. ğŸ”„ Activez les Ã©vÃ©nements souhaitÃ©s\n`;\n        result += `   3. ğŸ“Š Surveillez les logs de production\n`;\n      } else {\n        result += `   1. ğŸ”§ Corrigez les problÃ¨mes identifiÃ©s\n`;\n        result += `   2. ğŸ”„ Relancez le test\n`;\n        result += `   3. ğŸ“ Contactez l'Ã©quipe technique si nÃ©cessaire\n`;\n      }\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors du test du webhook: ${error.message}`;\n    }\n  }\n};\n\nexport const syncTools: ToolDefinition[] = [\n  syncMultiCms,\n  syncContent,\n  connectorList,\n  connectorConfigure,\n  apiWebhookCreate,\n  apiWebhookTest\n];"