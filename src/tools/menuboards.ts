/**
 * Menu boards management tools for Xibo MCP Server
 * Dynamic menu creation, pricing, scheduling and promotions
 * @author Xtranumerik Inc.
 */

import { ToolDefinition } from '../types.js';
import XiboClient from '../xibo-client.js';

// ========== MENU BOARD CREATION TOOLS ==========

const menuboardCreate: ToolDefinition = {
  name: 'menuboard_create',
  description: 'Create dynamic menu board layouts for restaurants and food service',
  parameters: [
    { name: 'name', type: 'string', description: 'Menu board name', required: true },
    { name: 'restaurant', type: 'string', description: 'Restaurant or establishment name', required: true },
    { name: 'menuType', type: 'string', description: 'Menu type: breakfast, lunch, dinner, drinks, desserts, full', required: false },
    { name: 'language', type: 'string', description: 'Menu language: french, english, bilingual', required: false },
    { name: 'priceFormat', type: 'string', description: 'Price format: cad, usd, both', required: false },
    { name: 'template', type: 'string', description: 'Template style: modern, classic, elegant, casual', required: false }
  ],
  handler: async (params: any) => {
    const client: XiboClient = params._xiboClient;
    
    try {
      const menuType = params.menuType || 'full';
      const language = params.language || 'bilingual';
      const priceFormat = params.priceFormat || 'cad';
      const template = params.template || 'modern';
      
      // Create layout for menu board
      const layoutData = {
        name: `Menu_${params.restaurant}_${params.name}_${Date.now()}`,
        description: `Menu dynamique pour ${params.restaurant} - ${params.name}`,
        tags: `menu,restaurant,${params.restaurant.toLowerCase()},${menuType},quebec`,
        width: 1920,
        height: 1080
      };
      
      const layoutResponse = await client.post('/layout', layoutData);
      const menuLayout = layoutResponse.data;
      
      // Create dataset for menu items
      const datasetData = {
        dataSet: `MenuData_${params.restaurant}_${Date.now()}`,
        description: `Donn√©es menu pour ${params.restaurant}`,
        code: `MENU_${params.restaurant.toUpperCase().replace(/\\s+/g, '_')}`
      };
      
      const datasetResponse = await client.post('/dataset', datasetData);
      const menuDataset = datasetResponse.data;
      
      // Add columns to dataset based on menu type and language
      const columns = [
        { heading: 'id', dataTypeId: 1, dataSetColumnTypeId: 1, listContent: '', columnOrder: 1 },
        { heading: 'category', dataTypeId: 1, dataSetColumnTypeId: 1, listContent: '', columnOrder: 2 }
      ];
      
      if (language === 'bilingual' || language === 'french') {
        columns.push({ heading: 'name_fr', dataTypeId: 1, dataSetColumnTypeId: 1, listContent: '', columnOrder: 3 });
        columns.push({ heading: 'description_fr', dataTypeId: 3, dataSetColumnTypeId: 1, listContent: '', columnOrder: 4 });
      }
      
      if (language === 'bilingual' || language === 'english') {
        columns.push({ heading: 'name_en', dataTypeId: 1, dataSetColumnTypeId: 1, listContent: '', columnOrder: 5 });
        columns.push({ heading: 'description_en', dataTypeId: 3, dataSetColumnTypeId: 1, listContent: '', columnOrder: 6 });
      }
      
      columns.push({ heading: 'price', dataTypeId: 2, dataSetColumnTypeId: 1, listContent: '', columnOrder: 7 });
      columns.push({ heading: 'available', dataTypeId: 1, dataSetColumnTypeId: 1, listContent: 'Oui,Non', columnOrder: 8 });
      columns.push({ heading: 'special', dataTypeId: 1, dataSetColumnTypeId: 1, listContent: '', columnOrder: 9 });
      
      // Add columns to dataset
      for (const column of columns) {
        await client.post(`/dataset/${menuDataset.dataSetId}/column`, column);
      }\n      
      // Create sample menu data based on Quebec cuisine\n      const sampleMenuItems = [\n        {\n          id: '1',\n          category: 'Entr√©es',\n          name_fr: 'Poutine Traditionnelle',\n          name_en: 'Traditional Poutine',\n          description_fr: 'Frites, sauce brune et fromage en grains',\n          description_en: 'Fries, gravy and cheese curds',\n          price: '8.99',\n          available: 'Oui',\n          special: ''\n        },\n        {\n          id: '2',\n          category: 'Plats Principaux',\n          name_fr: 'Tourti√®re du Lac-Saint-Jean',\n          name_en: 'Lac-Saint-Jean Meat Pie',\n          description_fr: 'Tourti√®re traditionnelle avec pommes de terre',\n          description_en: 'Traditional meat pie with potatoes',\n          price: '16.99',\n          available: 'Oui',\n          special: 'Sp√©cialit√©'\n        },\n        {\n          id: '3',\n          category: 'Desserts',\n          name_fr: 'Tarte au Sucre',\n          name_en: 'Sugar Pie',\n          description_fr: 'Dessert traditionnel qu√©b√©cois',\n          description_en: 'Traditional Quebec dessert',\n          price: '6.99',\n          available: 'Oui',\n          special: ''\n        }\n      ];\n      \n      // Add sample data to dataset\n      for (const item of sampleMenuItems) {\n        const rowData: any = {};\n        Object.entries(item).forEach(([key, value]) => {\n          rowData[key] = value;\n        });\n        \n        await client.post(`/dataset/${menuDataset.dataSetId}/data`, rowData);\n      }\n      \n      let result = `üçΩÔ∏è **Menu Board cr√©√© avec succ√®s**\\n\\n`;\n      result += `üìã **D√©tails du menu:**\\n`;\n      result += `   Restaurant: ${params.restaurant}\\n`;\n      result += `   Nom: ${params.name}\\n`;\n      result += `   Type: ${menuType}\\n`;\n      result += `   Langue: ${language}\\n`;\n      result += `   Format prix: ${priceFormat.toUpperCase()}\\n`;\n      result += `   Style: ${template}\\n\\n`;\n      \n      result += `üìä **√âl√©ments cr√©√©s:**\\n`;\n      result += `   Layout ID: ${menuLayout.layoutId}\\n`;\n      result += `   Dataset ID: ${menuDataset.dataSetId}\\n`;\n      result += `   Colonnes: ${columns.length}\\n`;\n      result += `   Items d'exemple: ${sampleMenuItems.length}\\n\\n`;\n      \n      result += `üçÅ **Items d'exemple (cuisine qu√©b√©coise):**\\n`;\n      sampleMenuItems.forEach((item: any, index: number) => {\n        const name = language === 'french' ? item.name_fr : item.name_en;\n        result += `   ${index + 1}. ${name} - ${item.price}$\\n`;\n      });\n      \n      result += `\\nüéØ **Prochaines √©tapes:**\\n`;\n      result += `   1. Ajoutez vos propres items avec menuboard_update_prices\\n`;\n      result += `   2. Organisez en cat√©gories avec menuboard_category_manage\\n`;\n      result += `   3. Cr√©ez des promotions avec menuboard_promotion\\n`;\n      result += `   4. Programmez des menus saisonniers avec menuboard_schedule_items\\n`;\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la cr√©ation du menu board: ${error.message}`;\n    }\n  }\n};\n\n// ========== PRICE AND ITEM MANAGEMENT TOOLS ==========\n\nconst menuboardUpdatePrices: ToolDefinition = {\n  name: 'menuboard_update_prices',\n  description: 'Update menu prices and items in bulk or individually',\n  parameters: [\n    { name: 'datasetId', type: 'number', description: 'Menu dataset ID', required: true },\n    { name: 'updateType', type: 'string', description: 'Update type: single, bulk, percentage', required: true },\n    { name: 'itemId', type: 'string', description: 'Item ID for single update', required: false },\n    { name: 'newPrice', type: 'number', description: 'New price for single update', required: false },\n    { name: 'priceAdjustment', type: 'number', description: 'Price adjustment (percentage for bulk)', required: false },\n    { name: 'category', type: 'string', description: 'Category filter for bulk update', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      // Get current menu data\n      const dataResponse = await client.get(`/dataset/${params.datasetId}/data`);\n      const menuItems = dataResponse.data.data || [];\n      \n      if (menuItems.length === 0) {\n        return '‚ùå Aucun item trouv√© dans le dataset du menu';\n      }\n      \n      let updatedItems: any[] = [];\n      let result = `üí∞ **Mise √† jour des prix du menu**\\n\\n`;\n      \n      switch (params.updateType.toLowerCase()) {\n        case 'single':\n          if (!params.itemId || !params.newPrice) {\n            return '‚ùå itemId et newPrice requis pour une mise √† jour simple';\n          }\n          \n          const singleItem = menuItems.find(item => item.id === params.itemId);\n          if (!singleItem) {\n            return `‚ùå Item avec ID \"${params.itemId}\" non trouv√©`;\n          }\n          \n          const oldPrice = parseFloat(singleItem.price || '0');\n          \n          // Update the item\n          await client.put(`/dataset/${params.datasetId}/data/${singleItem.id}`, {\n            ...singleItem,\n            price: params.newPrice.toFixed(2)\n          });\n          \n          updatedItems = [{ \n            ...singleItem, \n            oldPrice, \n            newPrice: params.newPrice,\n            change: params.newPrice - oldPrice\n          }];\n          \n          result += `‚úÖ **Item mis √† jour:**\\n`;\n          result += `   ${singleItem.name_fr || singleItem.name_en}\\n`;\n          result += `   Ancien prix: ${oldPrice.toFixed(2)}$\\n`;\n          result += `   Nouveau prix: ${params.newPrice.toFixed(2)}$\\n`;\n          result += `   Changement: ${(params.newPrice - oldPrice >= 0 ? '+' : '')}${(params.newPrice - oldPrice).toFixed(2)}$\\n`;\n          break;\n          \n        case 'bulk':\n        case 'percentage':\n          if (!params.priceAdjustment) {\n            return '‚ùå priceAdjustment requis pour une mise √† jour en lot';\n          }\n          \n          let itemsToUpdate = menuItems;\n          \n          // Filter by category if specified\n          if (params.category) {\n            itemsToUpdate = menuItems.filter(item => \n              item.category?.toLowerCase().includes(params.category.toLowerCase())\n            );\n          }\n          \n          if (itemsToUpdate.length === 0) {\n            return `‚ùå Aucun item trouv√© ${params.category ? `dans la cat√©gorie \"${params.category}\"` : ''}`;\n          }\n          \n          for (const item of itemsToUpdate) {\n            const oldPrice = parseFloat(item.price || '0');\n            let newPrice: number;\n            \n            if (params.updateType === 'percentage') {\n              newPrice = oldPrice * (1 + params.priceAdjustment / 100);\n            } else {\n              newPrice = oldPrice + params.priceAdjustment;\n            }\n            \n            // Ensure minimum price and reasonable precision\n            newPrice = Math.max(0.01, Math.round(newPrice * 100) / 100);\n            \n            await client.put(`/dataset/${params.datasetId}/data/${item.id}`, {\n              ...item,\n              price: newPrice.toFixed(2)\n            });\n            \n            updatedItems.push({\n              ...item,\n              oldPrice,\n              newPrice,\n              change: newPrice - oldPrice\n            });\n          }\n          \n          const adjustmentType = params.updateType === 'percentage' ? '%' : '$';\n          result += `üìä **Mise √† jour en lot:**\\n`;\n          result += `   Ajustement: ${params.priceAdjustment >= 0 ? '+' : ''}${params.priceAdjustment}${adjustmentType}\\n`;\n          result += `   ${params.category ? `Cat√©gorie: ${params.category}\\n   ` : ''}Items mis √† jour: ${updatedItems.length}\\n\\n`;\n          \n          break;\n          \n        default:\n          return `‚ùå Type de mise √† jour invalide: ${params.updateType}. Utilisez: single, bulk, percentage`;\n      }\n      \n      // Summary statistics\n      if (updatedItems.length > 1) {\n        const totalIncrease = updatedItems.reduce((sum, item) => sum + item.change, 0);\n        const avgChange = totalIncrease / updatedItems.length;\n        const increases = updatedItems.filter(item => item.change > 0).length;\n        const decreases = updatedItems.filter(item => item.change < 0).length;\n        \n        result += `üìà **Statistiques:**\\n`;\n        result += `   Augmentations: ${increases} items\\n`;\n        result += `   Diminutions: ${decreases} items\\n`;\n        result += `   Changement moyen: ${avgChange >= 0 ? '+' : ''}${avgChange.toFixed(2)}$\\n`;\n        result += `   Impact total: ${totalIncrease >= 0 ? '+' : ''}${totalIncrease.toFixed(2)}$\\n\\n`;\n      }\n      \n      // Show updated items\n      result += `üçΩÔ∏è **Items mis √† jour:**\\n`;\n      updatedItems.slice(0, 10).forEach((item: any, index: number) => {\n        const name = item.name_fr || item.name_en || `Item ${item.id}`;\n        const changeText = item.change >= 0 ? `+${item.change.toFixed(2)}` : `${item.change.toFixed(2)}`;\n        result += `   ${index + 1}. ${name}: ${item.oldPrice.toFixed(2)}$ ‚Üí ${item.newPrice.toFixed(2)}$ (${changeText}$)\\n`;\n      });\n      \n      if (updatedItems.length > 10) {\n        result += `   ... et ${updatedItems.length - 10} autres items\\n`;\n      }\n      \n      result += `\\n‚úÖ **Mise √† jour termin√©e avec succ√®s**\\n`;\n      result += `üí° **Les changements sont imm√©diats sur tous les √©crans connect√©s**`;\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la mise √† jour des prix: ${error.message}`;\n    }\n  }\n};\n\n// ========== SCHEDULING TOOLS ==========\n\nconst menuboardScheduleItems: ToolDefinition = {\n  name: 'menuboard_schedule_items',\n  description: 'Schedule seasonal items, limited-time offers, and daily specials',\n  parameters: [\n    { name: 'datasetId', type: 'number', description: 'Menu dataset ID', required: true },\n    { name: 'scheduleType', type: 'string', description: 'Schedule type: daily, weekly, seasonal, limited_time', required: true },\n    { name: 'itemIds', type: 'string', description: 'Comma-separated item IDs to schedule', required: true },\n    { name: 'startDate', type: 'string', description: 'Start date (YYYY-MM-DD)', required: false },\n    { name: 'endDate', type: 'string', description: 'End date (YYYY-MM-DD)', required: false },\n    { name: 'timeSlots', type: 'string', description: 'Time slots: breakfast,lunch,dinner or HH:MM-HH:MM', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      const itemIds = params.itemIds.split(',').map(id => id.trim());\n      const scheduleType = params.scheduleType.toLowerCase();\n      \n      // Get menu items to schedule\n      const dataResponse = await client.get(`/dataset/${params.datasetId}/data`);\n      const allMenuItems = dataResponse.data.data || [];\n      const itemsToSchedule = allMenuItems.filter(item => itemIds.includes(item.id));\n      \n      if (itemsToSchedule.length === 0) {\n        return '‚ùå Aucun item trouv√© avec les IDs sp√©cifi√©s';\n      }\n      \n      let result = `üìÖ **Programmation d'items de menu**\\n\\n`;\n      result += `üìã **Configuration:**\\n`;\n      result += `   Type: ${scheduleType}\\n`;\n      result += `   Items: ${itemsToSchedule.length}\\n`;\n      \n      if (params.startDate) result += `   D√©but: ${params.startDate}\\n`;\n      if (params.endDate) result += `   Fin: ${params.endDate}\\n`;\n      if (params.timeSlots) result += `   Cr√©neaux: ${params.timeSlots}\\n`;\n      \n      result += '\\n';\n      \n      // Create scheduling logic based on type\n      const scheduleConfigs: any = {\n        'daily': {\n          description: 'Sp√©ciaux du jour',\n          duration: '1 jour',\n          recurrence: 'Quotidienne',\n          example: 'Soupe du jour, Plat du chef'\n        },\n        'weekly': {\n          description: 'Sp√©ciaux hebdomadaires',\n          duration: '1 semaine',\n          recurrence: 'Hebdomadaire',\n          example: 'Lundi: P√¢tes, Mardi: Poisson'\n        },\n        'seasonal': {\n          description: 'Items saisonniers',\n          duration: '3 mois',\n          recurrence: 'Saisonni√®re',\n          example: 'Menu d\\'√©t√©, Menu des F√™tes'\n        },\n        'limited_time': {\n          description: 'Offre limit√©e',\n          duration: 'P√©riode sp√©cifi√©e',\n          recurrence: 'Unique',\n          example: 'Promotion sp√©ciale, Nouveau produit'\n        }\n      };\n      \n      const config = scheduleConfigs[scheduleType];\n      if (!config) {\n        return `‚ùå Type de programmation invalide: ${scheduleType}. Utilisez: ${Object.keys(scheduleConfigs).join(', ')}`;\n      }\n      \n      result += `‚öôÔ∏è **Type de programmation: ${config.description}**\\n`;\n      result += `   Dur√©e: ${config.duration}\\n`;\n      result += `   R√©currence: ${config.recurrence}\\n`;\n      result += `   Exemple: ${config.example}\\n\\n`;\n      \n      // Process time slots\n      let timeSlotDetails = 'Toute la journ√©e';\n      if (params.timeSlots) {\n        const slots = params.timeSlots.toLowerCase();\n        if (slots.includes('breakfast')) timeSlotDetails = '06:00-11:00 (D√©jeuner)';\n        else if (slots.includes('lunch')) timeSlotDetails = '11:00-15:00 (D√Æner)';\n        else if (slots.includes('dinner')) timeSlotDetails = '17:00-22:00 (Souper)';\n        else if (slots.includes('-')) timeSlotDetails = params.timeSlots;\n      }\n      \n      // Create campaign for scheduled items\n      const campaignName = `Menu_${scheduleType}_${Date.now()}`;\n      const campaignData = {\n        campaign: campaignName,\n        description: `${config.description} - Items programm√©s`,\n        startDt: params.startDate ? `${params.startDate}T00:00:00` : new Date().toISOString(),\n        endDt: params.endDate ? `${params.endDate}T23:59:59` : null\n      };\n      \n      const campaignResponse = await client.post('/campaign', campaignData);\n      const campaign = campaignResponse.data;\n      \n      // Update items with scheduling information\n      const updatedItems = [];\n      for (const item of itemsToSchedule) {\n        const scheduledInfo = {\n          scheduled: 'Oui',\n          schedule_type: scheduleType,\n          schedule_start: params.startDate || 'Imm√©diat',\n          schedule_end: params.endDate || 'Ind√©fini',\n          time_slots: timeSlotDetails\n        };\n        \n        // Add scheduling metadata to item\n        await client.put(`/dataset/${params.datasetId}/data/${item.id}`, {\n          ...item,\n          special: `${item.special || ''} [Programm√©: ${scheduleType}]`.trim()\n        });\n        \n        updatedItems.push({ ...item, ...scheduledInfo });\n      }\n      \n      result += `üéØ **Items programm√©s:**\\n`;\n      updatedItems.forEach((item: any, index: number) => {\n        const name = item.name_fr || item.name_en || `Item ${item.id}`;\n        result += `   ${index + 1}. ${name} (${item.price}$)\\n`;\n        result += `      ‚è∞ Horaires: ${timeSlotDetails}\\n`;\n        result += `      üìÖ P√©riode: ${item.schedule_start} ‚Üí ${item.schedule_end}\\n\\n`;\n      });\n      \n      result += `üìä **R√©sum√© de la programmation:**\\n`;\n      result += `   ‚úÖ Campagne cr√©√©e: ${campaign.campaignId}\\n`;\n      result += `   üçΩÔ∏è Items programm√©s: ${updatedItems.length}\\n`;\n      result += `   ‚è∞ Cr√©neaux horaires: ${timeSlotDetails}\\n`;\n      \n      if (scheduleType === 'seasonal') {\n        result += `\\nüçÅ **Suggestions saisonni√®res (Qu√©bec):**\\n`;\n        result += `   Printemps: Asperges, agneau, produits frais\\n`;\n        result += `   √ât√©: BBQ, salades, fruits locaux\\n`;\n        result += `   Automne: Courges, gibier, pommes du Qu√©bec\\n`;\n        result += `   Hiver: Rago√ªts, tourti√®res, comfort food\\n`;\n      }\n      \n      result += `\\n‚úÖ **Programmation activ√©e avec succ√®s**`;\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la programmation des items: ${error.message}`;\n    }\n  }\n};\n\n// ========== CATEGORY MANAGEMENT TOOLS ==========\n\nconst menuboardCategoryManage: ToolDefinition = {\n  name: 'menuboard_category_manage',\n  description: 'Manage menu categories, organization and display order',\n  parameters: [\n    { name: 'datasetId', type: 'number', description: 'Menu dataset ID', required: true },\n    { name: 'action', type: 'string', description: 'Action: list, create, reorder, rename, delete', required: true },\n    { name: 'categoryName', type: 'string', description: 'Category name for create/rename/delete', required: false },\n    { name: 'newCategoryName', type: 'string', description: 'New category name for rename', required: false },\n    { name: 'categoryOrder', type: 'string', description: 'Comma-separated category order', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      // Get current menu data\n      const dataResponse = await client.get(`/dataset/${params.datasetId}/data`);\n      const menuItems = dataResponse.data.data || [];\n      \n      let result = `üìÇ **Gestion des cat√©gories de menu**\\n\\n`;\n      \n      // Get current categories\n      const categories = [...new Set(menuItems.map(item => item.category).filter(Boolean))];\n      const categoryCounts: any = {};\n      \n      menuItems.forEach(item => {\n        if (item.category) {\n          categoryCounts[item.category] = (categoryCounts[item.category] || 0) + 1;\n        }\n      });\n      \n      switch (params.action.toLowerCase()) {\n        case 'list':\n          result += `üìã **Cat√©gories existantes (${categories.length}):**\\n\\n`;\n          \n          categories.forEach((category: string, index: number) => {\n            const count = categoryCounts[category] || 0;\n            result += `   ${index + 1}. **${category}** (${count} items)\\n`;\n            \n            // Show sample items in this category\n            const categoryItems = menuItems\n              .filter(item => item.category === category)\n              .slice(0, 3);\n            \n            categoryItems.forEach(item => {\n              const name = item.name_fr || item.name_en || `Item ${item.id}`;\n              result += `      - ${name} (${item.price}$)\\n`;\n            });\n            \n            if (categoryCounts[category] > 3) {\n              result += `      ... et ${categoryCounts[category] - 3} autres\\n`;\n            }\n            result += '\\n';\n          });\n          break;\n          \n        case 'create':\n          if (!params.categoryName) {\n            return '‚ùå categoryName requis pour cr√©er une cat√©gorie';\n          }\n          \n          if (categories.includes(params.categoryName)) {\n            return `‚ùå La cat√©gorie \"${params.categoryName}\" existe d√©j√†`;\n          }\n          \n          result += `‚úÖ **Nouvelle cat√©gorie cr√©√©e: \"${params.categoryName}\"**\\n\\n`;\n          result += `üí° **Pour ajouter des items √† cette cat√©gorie:**\\n`;\n          result += `   Utilisez menuboard_update_prices pour modifier\\n`;\n          result += `   la cat√©gorie des items existants\\n\\n`;\n          \n          result += `üçÅ **Suggestions de cat√©gories qu√©b√©coises:**\\n`;\n          result += `   - Entr√©es Traditionnelles\\n`;\n          result += `   - Plats du Terroir\\n`;\n          result += `   - Sp√©cialit√©s de la Maison\\n`;\n          result += `   - Desserts Qu√©b√©cois\\n`;\n          result += `   - Boissons Locales\\n`;\n          break;\n          \n        case 'rename':\n          if (!params.categoryName || !params.newCategoryName) {\n            return '‚ùå categoryName et newCategoryName requis pour renommer';\n          }\n          \n          if (!categories.includes(params.categoryName)) {\n            return `‚ùå Cat√©gorie \"${params.categoryName}\" non trouv√©e`;\n          }\n          \n          if (categories.includes(params.newCategoryName)) {\n            return `‚ùå La cat√©gorie \"${params.newCategoryName}\" existe d√©j√†`;\n          }\n          \n          // Update all items in this category\n          const itemsToRename = menuItems.filter(item => item.category === params.categoryName);\n          \n          for (const item of itemsToRename) {\n            await client.put(`/dataset/${params.datasetId}/data/${item.id}`, {\n              ...item,\n              category: params.newCategoryName\n            });\n          }\n          \n          result += `‚úÖ **Cat√©gorie renomm√©e:**\\n`;\n          result += `   \"${params.categoryName}\" ‚Üí \"${params.newCategoryName}\"\\n`;\n          result += `   Items mis √† jour: ${itemsToRename.length}\\n`;\n          break;\n          \n        case 'reorder':\n          if (!params.categoryOrder) {\n            return '‚ùå categoryOrder requis pour r√©organiser (ex: \"Entr√©es,Plats,Desserts\")';\n          }\n          \n          const newOrder = params.categoryOrder.split(',').map(cat => cat.trim());\n          const invalidCategories = newOrder.filter(cat => !categories.includes(cat));\n          \n          if (invalidCategories.length > 0) {\n            return `‚ùå Cat√©gories invalides: ${invalidCategories.join(', ')}`;\n          }\n          \n          result += `üîÑ **Nouvel ordre des cat√©gories:**\\n`;\n          newOrder.forEach((category: string, index: number) => {\n            const count = categoryCounts[category] || 0;\n            result += `   ${index + 1}. ${category} (${count} items)\\n`;\n          });\n          \n          // Note: Actual reordering would require layout modifications\n          result += `\\nüí° **Pour appliquer cet ordre:**\\n`;\n          result += `   Modifiez le layout du menu pour refl√©ter\\n`;\n          result += `   cette organisation des cat√©gories\\n`;\n          break;\n          \n        case 'delete':\n          if (!params.categoryName) {\n            return '‚ùå categoryName requis pour supprimer une cat√©gorie';\n          }\n          \n          if (!categories.includes(params.categoryName)) {\n            return `‚ùå Cat√©gorie \"${params.categoryName}\" non trouv√©e`;\n          }\n          \n          const itemsInCategory = menuItems.filter(item => item.category === params.categoryName);\n          \n          if (itemsInCategory.length > 0) {\n            result += `‚ö†Ô∏è **Attention: ${itemsInCategory.length} items dans cette cat√©gorie**\\n\\n`;\n            result += `üîÑ **Options:**\\n`;\n            result += `   1. D√©placez les items vers une autre cat√©gorie\\n`;\n            result += `   2. Supprimez d'abord tous les items\\n`;\n            result += `   3. Les items deviendront \"Sans cat√©gorie\"\\n\\n`;\n            \n            // Show items that would be affected\n            result += `üìã **Items concern√©s:**\\n`;\n            itemsInCategory.slice(0, 5).forEach((item: any, index: number) => {\n              const name = item.name_fr || item.name_en || `Item ${item.id}`;\n              result += `   ${index + 1}. ${name}\\n`;\n            });\n            \n            if (itemsInCategory.length > 5) {\n              result += `   ... et ${itemsInCategory.length - 5} autres\\n`;\n            }\n          } else {\n            result += `‚úÖ **Cat√©gorie \"${params.categoryName}\" supprim√©e**\\n`;\n            result += `   Aucun item n'√©tait dans cette cat√©gorie\\n`;\n          }\n          break;\n          \n        default:\n          return `‚ùå Action invalide: ${params.action}. Utilisez: list, create, reorder, rename, delete`;\n      }\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la gestion des cat√©gories: ${error.message}`;\n    }\n  }\n};\n\n// ========== PROMOTION MANAGEMENT TOOLS ==========\n\nconst menuboardPromotion: ToolDefinition = {\n  name: 'menuboard_promotion',\n  description: 'Create and manage promotions, specials, and combo deals',\n  parameters: [\n    { name: 'datasetId', type: 'number', description: 'Menu dataset ID', required: true },\n    { name: 'promoType', type: 'string', description: 'Promo type: discount, combo, happy_hour, special', required: true },\n    { name: 'title', type: 'string', description: 'Promotion title', required: true },\n    { name: 'itemIds', type: 'string', description: 'Comma-separated item IDs for promotion', required: true },\n    { name: 'discount', type: 'number', description: 'Discount percentage or amount', required: false },\n    { name: 'comboPrice', type: 'number', description: 'Special combo price', required: false },\n    { name: 'validUntil', type: 'string', description: 'Promotion end date (YYYY-MM-DD)', required: false }\n  ],\n  handler: async (params: any) => {\n    const client: XiboClient = params._xiboClient;\n    \n    try {\n      const itemIds = params.itemIds.split(',').map(id => id.trim());\n      const promoType = params.promoType.toLowerCase();\n      \n      // Get menu items for promotion\n      const dataResponse = await client.get(`/dataset/${params.datasetId}/data`);\n      const allMenuItems = dataResponse.data.data || [];\n      const promoItems = allMenuItems.filter(item => itemIds.includes(item.id));\n      \n      if (promoItems.length === 0) {\n        return '‚ùå Aucun item trouv√© avec les IDs sp√©cifi√©s';\n      }\n      \n      let result = `üéâ **Cr√©ation de promotion**\\n\\n`;\n      result += `üìã **D√©tails:**\\n`;\n      result += `   Titre: ${params.title}\\n`;\n      result += `   Type: ${promoType}\\n`;\n      result += `   Items: ${promoItems.length}\\n`;\n      if (params.validUntil) result += `   Valide jusqu'au: ${params.validUntil}\\n`;\n      result += '\\n';\n      \n      // Calculate promotion details based on type\n      let promoDetails = '';\n      let totalOriginalPrice = promoItems.reduce((sum, item) => sum + parseFloat(item.price || '0'), 0);\n      let promoPrice = totalOriginalPrice;\n      let savings = 0;\n      \n      switch (promoType) {\n        case 'discount':\n          if (!params.discount) {\n            return '‚ùå discount requis pour une promotion √† rabais';\n          }\n          \n          savings = totalOriginalPrice * (params.discount / 100);\n          promoPrice = totalOriginalPrice - savings;\n          promoDetails = `${params.discount}% de rabais`;\n          \n          result += `üí∞ **Promotion √† rabais:**\\n`;\n          result += `   Rabais: ${params.discount}%\\n`;\n          result += `   Prix original: ${totalOriginalPrice.toFixed(2)}$\\n`;\n          result += `   Prix promotionnel: ${promoPrice.toFixed(2)}$\\n`;\n          result += `   √âconomies: ${savings.toFixed(2)}$\\n\\n`;\n          break;\n          \n        case 'combo':\n          if (!params.comboPrice) {\n            return '‚ùå comboPrice requis pour un combo';\n          }\n          \n          promoPrice = params.comboPrice;\n          savings = totalOriginalPrice - promoPrice;\n          promoDetails = `Combo sp√©cial √† ${params.comboPrice}$`;\n          \n          result += `üçΩÔ∏è **Combo sp√©cial:**\\n`;\n          result += `   Prix combo: ${params.comboPrice.toFixed(2)}$\\n`;\n          result += `   Prix s√©par√©: ${totalOriginalPrice.toFixed(2)}$\\n`;\n          result += `   √âconomies: ${savings.toFixed(2)}$ (${((savings / totalOriginalPrice) * 100).toFixed(1)}%)\\n\\n`;\n          break;\n          \n        case 'happy_hour':\n          const happyDiscount = params.discount || 25;\n          savings = totalOriginalPrice * (happyDiscount / 100);\n          promoPrice = totalOriginalPrice - savings;\n          promoDetails = `Happy Hour - ${happyDiscount}% de rabais`;\n          \n          result += `üïï **Happy Hour:**\\n`;\n          result += `   Horaire: 15h00 - 18h00\\n`;\n          result += `   Rabais: ${happyDiscount}%\\n`;\n          result += `   Prix Happy Hour: ${promoPrice.toFixed(2)}$\\n`;\n          result += `   √âconomies: ${savings.toFixed(2)}$\\n\\n`;\n          break;\n          \n        case 'special':\n          promoDetails = 'Sp√©cial de la maison';\n          result += `‚≠ê **Sp√©cial de la maison:**\\n`;\n          result += `   Promotion exclusive\\n`;\n          result += `   Prix r√©gulier maintenu\\n`;\n          result += `   Mise en valeur sp√©ciale\\n\\n`;\n          break;\n          \n        default:\n          return `‚ùå Type de promotion invalide: ${promoType}. Utilisez: discount, combo, happy_hour, special`;\n      }\n      \n      // Update items with promotion information\n      const updatedItems = [];\n      for (const item of promoItems) {\n        const promoInfo = {\n          promotion: params.title,\n          promo_type: promoType,\n          promo_details: promoDetails,\n          promo_valid_until: params.validUntil || '',\n          original_price: item.price\n        };\n        \n        // Update special field to include promotion\n        const newSpecial = `${item.special || ''} [${params.title}]`.trim();\n        \n        await client.put(`/dataset/${params.datasetId}/data/${item.id}`, {\n          ...item,\n          special: newSpecial,\n          // Add promotion metadata if needed\n          promo_active: 'Oui'\n        });\n        \n        updatedItems.push({ ...item, ...promoInfo });\n      }\n      \n      result += `üéØ **Items en promotion:**\\n`;\n      updatedItems.forEach((item: any, index: number) => {\n        const name = item.name_fr || item.name_en || `Item ${item.id}`;\n        result += `   ${index + 1}. ${name}\\n`;\n        result += `      Prix: ${item.price}$\\n`;\n        result += `      Cat√©gorie: ${item.category}\\n\\n`;\n      });\n      \n      // Quebec-specific promotion suggestions\n      result += `üçÅ **Suggestions promotions qu√©b√©coises:**\\n`;\n      result += `   ‚Ä¢ \"5 √† 7 Qu√©b√©cois\" - Happy hour avec produits locaux\\n`;\n      result += `   ‚Ä¢ \"Combo Cabane\" - Menu traditionnel √† prix fixe\\n`;\n      result += `   ‚Ä¢ \"Sp√©cial St-Jean\" - Promotions f√™te nationale\\n`;\n      result += `   ‚Ä¢ \"Menu Hiver\" - R√©confort et chaleur\\n\\n`;\n      \n      result += `üìä **R√©sum√© de la promotion:**\\n`;\n      result += `   ‚úÖ Promotion cr√©√©e: ${params.title}\\n`;\n      result += `   üçΩÔ∏è Items inclus: ${updatedItems.length}\\n`;\n      if (savings > 0) result += `   üí∞ √âconomies client: ${savings.toFixed(2)}$\\n`;\n      result += `   üìÖ ${params.validUntil ? `Valide jusqu'au ${params.validUntil}` : 'Dur√©e ind√©finie'}\\n`;\n      \n      result += `\\n‚úÖ **Promotion activ√©e sur tous les √©crans**`;\n      \n      return result;\n    } catch (error: any) {\n      return `Erreur lors de la cr√©ation de la promotion: ${error.message}`;\n    }\n  }\n};\n\nexport const menuboardTools: ToolDefinition[] = [\n  menuboardCreate,\n  menuboardUpdatePrices,\n  menuboardScheduleItems,\n  menuboardCategoryManage,\n  menuboardPromotion\n];"